from .main_attack_script import main_function
from .header_script import headers_reader, UserAgent, HTTP_HEADER
import re

# importing values from model
from scanner.models import VulnerabilityPayloads

# fetch payload with respect to vulnerability_type
def fetch_payload(vuln_cat_id):
    payloads = []
    all_payloads = list(VulnerabilityPayloads.objects.filter(vulnerability_id=vuln_cat_id))
    if all_payloads is None:
        print("No payloads found")
    else:
        for pld in all_payloads:
            payloads.append(pld.vuln_payload)   

    return payloads

# code for Remote Code Execution
def rce_func(url, scan_detail_id):
    print("[*] Checking for remote code execution")
    headers_reader(url)
    payloads = fetch_payload(3)
    check = re.compile("51107ed95250b4099a0f481221d56497|Linux|eval\(\)|SERVER_ADDR|Volume.+Serial|\[boot", re.I)
    solution = main_function(url, payloads, check, 3, scan_detail_id)
    return solution

# code for SQL injection
def error_based_sqli_func(url, scan_detail_id):
    print("[*] Checking for SQL Injection")
    payloads = fetch_payload(1)
    check = re.compile("Incorrect syntax|Syntax error|Unclosed.+mark|unterminated.+qoute|SQL.+Server|Microsoft.+Database|Fatal.+error", re.I)
    solution =  main_function(url, payloads, check, 1, scan_detail_id)
    return solution

#Code for Cross Site Scripting
def xss_func(url, scan_detail_id):
    print("[*] Checking for Cross site scripting")
    payloads = fetch_payload(2)
    check = re.compile('zigoo0<svg|x>x', re.I)
    solution =  main_function(url, payloads, check, 2, scan_detail_id)
    return solution